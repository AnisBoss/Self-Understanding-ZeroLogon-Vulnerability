### Self-Understanding of ZeroLogon Vulnerability

Since the discovery of the vulnerability by Secura, i tried to further understand the source of issue.

##### Step1 :

The NetLogon protocol consists of multiple steps ; it starts with a communication through a challenge client (**CC**) and challenge server (**SC**).

Client ===++++=================> Server
			8 bytes challenge
Client <============+++++======= Server
			8 bytes challenge

##### Step2:

A secret is stored under <font color="red">HKLM\SECURITY\POLICY\Secrets</font> on the client machine ; on the DC is stored in AD database; will be used in order to compute the sessionKey that will be used later in the encryption step. the pseudocode looks like the following

```python
hstring = CC + CS #concatenation of client challenge and server challenge
secret = getSecretPassword() #secret stored in registry if it's local ;
final_hash = HMAC_SHA256(secret,hstring) 
SessionKey = final_hash[:16:] #get only first 16 bytes
```

At this step client and server should have the same **sessionKey** that will be used later as AES key ;) ; keep that in mind

##### Step 3 : Verification

```python
iv = random #should be random
key = sessionKey #already computed
cfb8 = AES_cfb8(iv,key) #use CFB 8 bits mode
ciphertext = cfb8.encrypt(ClientChallenge)
```

Client ===++++=================> Server
			ciphertext

Server checks if its the same as exchanged during the start

###### how AES_CFB8 works :

```python
Plaintext = "ABCDEF"
IV = "0123456789012345"
```

###### 1st step:

```python
AES_ECB(IV) ==> keystream = "9616156165158143" #get keystream  
A ^ 9  ==> '\x16' #simple xor of byte from plaintext and one byte from keystream
```

###### 2nd step:

```python
AES_ECB(IV+'\x16') ==> keystream ="7815101384035740"
B ^ 7 ==> E
```

[....] until the plaintext is finished

![cfb8](cfb8.png)




It's crucial to mention Microsoft documentation of NETLOGON protocol describing how netlogon credentials are computed : 

```If AES support is negotiated between the client and the server, 
   the Netlogon  credentials are computed using the AES-128 encryption 
   algorithm in 8-bit CFB  mode with a zero initialization vector. 
   [Sk below is short for SessionKey]     
         ComputeNetlogonCredential(Input, Sk, Output)       
         SET IV = 0       
         CALL AesEncrypt(Input, Sk, IV, Output) 
```

**What vulnerability could occurs here ?**

![zero_cfb](zero_cfb.png)

AES is a high quality cipher  ==> fully random ; the chance of an individual bit is 50% 0 and 50% 1 ;

So our goal is to make the  ciphertext all zeroes ; but how ? 

the chance of getting the first byte of keystream 0 is :

50% * 50% * 50% * ... *50% <== 8 times ; == 1/256 == 2^*-8 ; because one byte is 8 bits.

When getting 00 as first byte ; next iteration will be the same as the first iteration .

Which will make the ciphertext all-zeroes.

##### Ciphertext all-zeroes .. SO WHAT ?

hopefully for us, there is a NETLOGON password function (since it's an RPC) called <font color="red">NetrServerPasswordSet2</font> which can be remotely called from a session that has already got past the credentials verification.

This function consists of encrypting 2 chunks :

- the origincal Client Challenge(**CS**) + Timestamp in order to ensure it's still the same client program.
- A buffer of 516 bytes that specifies the new password + length of the password

The **CS** must be always zeroes , because that's needed to get the first part of the exploit.
the problem how to get a totally nulled **CS** with current timestamp ?
Microsoft comes another time with a stupid behavior; it does not check if the provided timestamp was decades in the past.

The next chunk is just straight forward we need to supply a 0 length password which also accepted by the remote server.
**Changing the password of a computer could be a dangerous DOS exploit ; since we will change it only in the AD ; the targeted computer itself will still locally store its original password which will make it impossible to login again on domain controller without manual fix** 

so the exploit chain is as follows :

1. Bypass authentication through brute forcing until we get all-zeroes as ciphertext.

2.  set null password to any account

3. use the normal procedure of NETLOGON since we know the password now ; and change it to non empty password

4. Calling <font color="red">NetrServerPasswordGet </font> in order to get all NTLM of registered users on AD; this can be done also using secretsdump from <font color="red">impacket</font> with the DC password.

   